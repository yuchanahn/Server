// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BASE_H_
#define FLATBUFFERS_GENERATED_BASE_H_

#include "flatbuffers/flatbuffers.h"

struct Vec3;

struct FirstCharacterData;
struct FirstCharacterDataT;

struct Login;
struct LoginT;

struct id;
struct idT;

struct ping;
struct pingT;

struct test;
struct testT;

struct Player;
struct PlayerT;

struct Monster;
struct MonsterT;

struct MonsterStat;
struct MonsterStatT;

struct PlayerStat;
struct PlayerStatT;

struct SendMeStat;
struct SendMeStatT;

struct Base;
struct BaseT;

enum Class {
	Class_Base = 0,
	Class_Player = 1,
	Class_id = 2,
	Class_test = 3,
	Class_ping = 4,
	Class_PlayerStat = 5,
	Class_SendMeStat = 6,
	Class_Monster = 7,
	Class_MonsterStat = 8,
	Class_LogIn = 9,
	Class_FirstCharacterData = 10,
	Class_MIN = Class_Base,
	Class_MAX = Class_FirstCharacterData
};

inline const Class(&EnumValuesClass())[11]{
	static const Class values[] = {
	Class_Base,
	Class_Player,
	Class_id,
	Class_test,
	Class_ping,
	Class_PlayerStat,
	Class_SendMeStat,
	Class_Monster,
	Class_MonsterStat,
	Class_LogIn,
	Class_FirstCharacterData
};
return values;
}

inline const char * const *EnumNamesClass() {
	static const char * const names[] = {
		"Base",
		"Player",
		"id",
		"test",
		"ping",
		"PlayerStat",
		"SendMeStat",
		"Monster",
		"MonsterStat",
		"LogIn",
		"FirstCharacterData",
		nullptr
	};
	return names;
}

inline const char *EnumNameClass(Class e) {
	const size_t index = static_cast<int>(e);
	return EnumNamesClass()[index];
}

MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
private:
	float x_;
	float y_;
	float z_;

public:
	Vec3() {
		memset(this, 0, sizeof(Vec3));
	}
	Vec3(float _x, float _y, float _z)
		: x_(flatbuffers::EndianScalar(_x)),
		y_(flatbuffers::EndianScalar(_y)),
		z_(flatbuffers::EndianScalar(_z)) {
	}
	float x() const {
		return flatbuffers::EndianScalar(x_);
	}
	float y() const {
		return flatbuffers::EndianScalar(y_);
	}
	float z() const {
		return flatbuffers::EndianScalar(z_);
	}
};
STRUCT_END(Vec3, 12);

struct FirstCharacterDataT : public flatbuffers::NativeTable {
	typedef FirstCharacterData TableType;
	Class cType;
	std::unique_ptr<Vec3> Pos;
	int32_t HP;
	int32_t HPLim;
	int32_t MP;
	int32_t MPLim;
	int32_t LV;
	int32_t ID;
	FirstCharacterDataT()
		: cType(Class_Base),
		HP(0),
		HPLim(0),
		MP(0),
		MPLim(0),
		LV(0),
		ID(0) {
	}
};

struct FirstCharacterData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef FirstCharacterDataT NativeTableType;
	enum {
		VT_CTYPE = 4,
		VT_POS = 6,
		VT_HP = 8,
		VT_HPLIM = 10,
		VT_MP = 12,
		VT_MPLIM = 14,
		VT_LV = 16,
		VT_ID = 18
	};
	Class cType() const {
		return static_cast<Class>(GetField<int32_t>(VT_CTYPE, 0));
	}
	const Vec3 *Pos() const {
		return GetStruct<const Vec3 *>(VT_POS);
	}
	int32_t HP() const {
		return GetField<int32_t>(VT_HP, 0);
	}
	int32_t HPLim() const {
		return GetField<int32_t>(VT_HPLIM, 0);
	}
	int32_t MP() const {
		return GetField<int32_t>(VT_MP, 0);
	}
	int32_t MPLim() const {
		return GetField<int32_t>(VT_MPLIM, 0);
	}
	int32_t LV() const {
		return GetField<int32_t>(VT_LV, 0);
	}
	int32_t ID() const {
		return GetField<int32_t>(VT_ID, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
			VerifyField<int32_t>(verifier, VT_CTYPE) &&
			VerifyField<Vec3>(verifier, VT_POS) &&
			VerifyField<int32_t>(verifier, VT_HP) &&
			VerifyField<int32_t>(verifier, VT_HPLIM) &&
			VerifyField<int32_t>(verifier, VT_MP) &&
			VerifyField<int32_t>(verifier, VT_MPLIM) &&
			VerifyField<int32_t>(verifier, VT_LV) &&
			VerifyField<int32_t>(verifier, VT_ID) &&
			verifier.EndTable();
	}
	FirstCharacterDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(FirstCharacterDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<FirstCharacterData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FirstCharacterDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FirstCharacterDataBuilder {
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_cType(Class cType) {
		fbb_.AddElement<int32_t>(FirstCharacterData::VT_CTYPE, static_cast<int32_t>(cType), 0);
	}
	void add_Pos(const Vec3 *Pos) {
		fbb_.AddStruct(FirstCharacterData::VT_POS, Pos);
	}
	void add_HP(int32_t HP) {
		fbb_.AddElement<int32_t>(FirstCharacterData::VT_HP, HP, 0);
	}
	void add_HPLim(int32_t HPLim) {
		fbb_.AddElement<int32_t>(FirstCharacterData::VT_HPLIM, HPLim, 0);
	}
	void add_MP(int32_t MP) {
		fbb_.AddElement<int32_t>(FirstCharacterData::VT_MP, MP, 0);
	}
	void add_MPLim(int32_t MPLim) {
		fbb_.AddElement<int32_t>(FirstCharacterData::VT_MPLIM, MPLim, 0);
	}
	void add_LV(int32_t LV) {
		fbb_.AddElement<int32_t>(FirstCharacterData::VT_LV, LV, 0);
	}
	void add_ID(int32_t ID) {
		fbb_.AddElement<int32_t>(FirstCharacterData::VT_ID, ID, 0);
	}
	explicit FirstCharacterDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
		: fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	FirstCharacterDataBuilder &operator=(const FirstCharacterDataBuilder &);
	flatbuffers::Offset<FirstCharacterData> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<FirstCharacterData>(end);
		return o;
	}
};

inline flatbuffers::Offset<FirstCharacterData> CreateFirstCharacterData(
	flatbuffers::FlatBufferBuilder &_fbb,
	Class cType = Class_Base,
	const Vec3 *Pos = 0,
	int32_t HP = 0,
	int32_t HPLim = 0,
	int32_t MP = 0,
	int32_t MPLim = 0,
	int32_t LV = 0,
	int32_t ID = 0) {
	FirstCharacterDataBuilder builder_(_fbb);
	builder_.add_ID(ID);
	builder_.add_LV(LV);
	builder_.add_MPLim(MPLim);
	builder_.add_MP(MP);
	builder_.add_HPLim(HPLim);
	builder_.add_HP(HP);
	builder_.add_Pos(Pos);
	builder_.add_cType(cType);
	return builder_.Finish();
}

flatbuffers::Offset<FirstCharacterData> CreateFirstCharacterData(flatbuffers::FlatBufferBuilder &_fbb, const FirstCharacterDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LoginT : public flatbuffers::NativeTable {
	typedef Login TableType;
	Class cType;
	bool isSignin;
	std::string id;
	std::string pass;
	bool isSuccess;
	LoginT()
		: cType(Class_Base),
		isSignin(false),
		isSuccess(false) {
	}
};

struct Login FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef LoginT NativeTableType;
	enum {
		VT_CTYPE = 4,
		VT_ISSIGNIN = 6,
		VT_ID = 8,
		VT_PASS = 10,
		VT_ISSUCCESS = 12
	};
	Class cType() const {
		return static_cast<Class>(GetField<int32_t>(VT_CTYPE, 0));
	}
	bool isSignin() const {
		return GetField<uint8_t>(VT_ISSIGNIN, 0) != 0;
	}
	const flatbuffers::String *id() const {
		return GetPointer<const flatbuffers::String *>(VT_ID);
	}
	const flatbuffers::String *pass() const {
		return GetPointer<const flatbuffers::String *>(VT_PASS);
	}
	bool isSuccess() const {
		return GetField<uint8_t>(VT_ISSUCCESS, 0) != 0;
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
			VerifyField<int32_t>(verifier, VT_CTYPE) &&
			VerifyField<uint8_t>(verifier, VT_ISSIGNIN) &&
			VerifyOffset(verifier, VT_ID) &&
			verifier.Verify(id()) &&
			VerifyOffset(verifier, VT_PASS) &&
			verifier.Verify(pass()) &&
			VerifyField<uint8_t>(verifier, VT_ISSUCCESS) &&
			verifier.EndTable();
	}
	LoginT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(LoginT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<Login> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoginT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LoginBuilder {
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_cType(Class cType) {
		fbb_.AddElement<int32_t>(Login::VT_CTYPE, static_cast<int32_t>(cType), 0);
	}
	void add_isSignin(bool isSignin) {
		fbb_.AddElement<uint8_t>(Login::VT_ISSIGNIN, static_cast<uint8_t>(isSignin), 0);
	}
	void add_id(flatbuffers::Offset<flatbuffers::String> id) {
		fbb_.AddOffset(Login::VT_ID, id);
	}
	void add_pass(flatbuffers::Offset<flatbuffers::String> pass) {
		fbb_.AddOffset(Login::VT_PASS, pass);
	}
	void add_isSuccess(bool isSuccess) {
		fbb_.AddElement<uint8_t>(Login::VT_ISSUCCESS, static_cast<uint8_t>(isSuccess), 0);
	}
	explicit LoginBuilder(flatbuffers::FlatBufferBuilder &_fbb)
		: fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	LoginBuilder &operator=(const LoginBuilder &);
	flatbuffers::Offset<Login> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Login>(end);
		return o;
	}
};

inline flatbuffers::Offset<Login> CreateLogin(
	flatbuffers::FlatBufferBuilder &_fbb,
	Class cType = Class_Base,
	bool isSignin = false,
	flatbuffers::Offset<flatbuffers::String> id = 0,
	flatbuffers::Offset<flatbuffers::String> pass = 0,
	bool isSuccess = false) {
	LoginBuilder builder_(_fbb);
	builder_.add_pass(pass);
	builder_.add_id(id);
	builder_.add_cType(cType);
	builder_.add_isSuccess(isSuccess);
	builder_.add_isSignin(isSignin);
	return builder_.Finish();
}

inline flatbuffers::Offset<Login> CreateLoginDirect(
	flatbuffers::FlatBufferBuilder &_fbb,
	Class cType = Class_Base,
	bool isSignin = false,
	const char *id = nullptr,
	const char *pass = nullptr,
	bool isSuccess = false) {
	return CreateLogin(
		_fbb,
		cType,
		isSignin,
		id ? _fbb.CreateString(id) : 0,
		pass ? _fbb.CreateString(pass) : 0,
		isSuccess);
}

flatbuffers::Offset<Login> CreateLogin(flatbuffers::FlatBufferBuilder &_fbb, const LoginT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct idT : public flatbuffers::NativeTable {
	typedef id TableType;
	Class cType;
	int32_t ID;
	idT()
		: cType(Class_Base),
		ID(0) {
	}
};

struct id FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef idT NativeTableType;
	enum {
		VT_CTYPE = 4,
		VT_ID = 6
	};
	Class cType() const {
		return static_cast<Class>(GetField<int32_t>(VT_CTYPE, 0));
	}
	int32_t ID() const {
		return GetField<int32_t>(VT_ID, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
			VerifyField<int32_t>(verifier, VT_CTYPE) &&
			VerifyField<int32_t>(verifier, VT_ID) &&
			verifier.EndTable();
	}
	idT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(idT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<id> Pack(flatbuffers::FlatBufferBuilder &_fbb, const idT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct idBuilder {
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_cType(Class cType) {
		fbb_.AddElement<int32_t>(id::VT_CTYPE, static_cast<int32_t>(cType), 0);
	}
	void add_ID(int32_t ID) {
		fbb_.AddElement<int32_t>(id::VT_ID, ID, 0);
	}
	explicit idBuilder(flatbuffers::FlatBufferBuilder &_fbb)
		: fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	idBuilder &operator=(const idBuilder &);
	flatbuffers::Offset<id> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<id>(end);
		return o;
	}
};

inline flatbuffers::Offset<id> Createid(
	flatbuffers::FlatBufferBuilder &_fbb,
	Class cType = Class_Base,
	int32_t ID = 0) {
	idBuilder builder_(_fbb);
	builder_.add_ID(ID);
	builder_.add_cType(cType);
	return builder_.Finish();
}

flatbuffers::Offset<id> Createid(flatbuffers::FlatBufferBuilder &_fbb, const idT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct pingT : public flatbuffers::NativeTable {
	typedef ping TableType;
	Class cType;
	int64_t time;
	pingT()
		: cType(Class_Base),
		time(0) {
	}
};

struct ping FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef pingT NativeTableType;
	enum {
		VT_CTYPE = 4,
		VT_TIME = 6
	};
	Class cType() const {
		return static_cast<Class>(GetField<int32_t>(VT_CTYPE, 0));
	}
	int64_t time() const {
		return GetField<int64_t>(VT_TIME, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
			VerifyField<int32_t>(verifier, VT_CTYPE) &&
			VerifyField<int64_t>(verifier, VT_TIME) &&
			verifier.EndTable();
	}
	pingT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(pingT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<ping> Pack(flatbuffers::FlatBufferBuilder &_fbb, const pingT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct pingBuilder {
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_cType(Class cType) {
		fbb_.AddElement<int32_t>(ping::VT_CTYPE, static_cast<int32_t>(cType), 0);
	}
	void add_time(int64_t time) {
		fbb_.AddElement<int64_t>(ping::VT_TIME, time, 0);
	}
	explicit pingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
		: fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	pingBuilder &operator=(const pingBuilder &);
	flatbuffers::Offset<ping> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<ping>(end);
		return o;
	}
};

inline flatbuffers::Offset<ping> Createping(
	flatbuffers::FlatBufferBuilder &_fbb,
	Class cType = Class_Base,
	int64_t time = 0) {
	pingBuilder builder_(_fbb);
	builder_.add_time(time);
	builder_.add_cType(cType);
	return builder_.Finish();
}

flatbuffers::Offset<ping> Createping(flatbuffers::FlatBufferBuilder &_fbb, const pingT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct testT : public flatbuffers::NativeTable {
	typedef test TableType;
	Class cType;
	int64_t num;
	testT()
		: cType(Class_Base),
		num(0) {
	}
};

struct test FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef testT NativeTableType;
	enum {
		VT_CTYPE = 4,
		VT_NUM = 6
	};
	Class cType() const {
		return static_cast<Class>(GetField<int32_t>(VT_CTYPE, 0));
	}
	int64_t num() const {
		return GetField<int64_t>(VT_NUM, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
			VerifyField<int32_t>(verifier, VT_CTYPE) &&
			VerifyField<int64_t>(verifier, VT_NUM) &&
			verifier.EndTable();
	}
	testT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(testT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<test> Pack(flatbuffers::FlatBufferBuilder &_fbb, const testT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct testBuilder {
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_cType(Class cType) {
		fbb_.AddElement<int32_t>(test::VT_CTYPE, static_cast<int32_t>(cType), 0);
	}
	void add_num(int64_t num) {
		fbb_.AddElement<int64_t>(test::VT_NUM, num, 0);
	}
	explicit testBuilder(flatbuffers::FlatBufferBuilder &_fbb)
		: fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	testBuilder &operator=(const testBuilder &);
	flatbuffers::Offset<test> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<test>(end);
		return o;
	}
};

inline flatbuffers::Offset<test> Createtest(
	flatbuffers::FlatBufferBuilder &_fbb,
	Class cType = Class_Base,
	int64_t num = 0) {
	testBuilder builder_(_fbb);
	builder_.add_num(num);
	builder_.add_cType(cType);
	return builder_.Finish();
}

flatbuffers::Offset<test> Createtest(flatbuffers::FlatBufferBuilder &_fbb, const testT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PlayerT : public flatbuffers::NativeTable {
	typedef Player TableType;
	Class cType;
	std::unique_ptr<Vec3> pos;
	std::unique_ptr<Vec3> vel;
	std::unique_ptr<Vec3> rot;
	float w;
	int32_t ID;
	float Vertical;
	float Horizontal;
	bool Jump;
	bool Attack;
	bool Run;
	PlayerT()
		: cType(Class_Base),
		w(0.0f),
		ID(0),
		Vertical(0.0f),
		Horizontal(0.0f),
		Jump(false),
		Attack(false),
		Run(false) {
	}
};

struct Player FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef PlayerT NativeTableType;
	enum {
		VT_CTYPE = 4,
		VT_POS = 6,
		VT_VEL = 8,
		VT_ROT = 10,
		VT_W = 12,
		VT_ID = 14,
		VT_VERTICAL = 16,
		VT_HORIZONTAL = 18,
		VT_JUMP = 20,
		VT_ATTACK = 22,
		VT_RUN = 24
	};
	Class cType() const {
		return static_cast<Class>(GetField<int32_t>(VT_CTYPE, 0));
	}
	const Vec3 *pos() const {
		return GetStruct<const Vec3 *>(VT_POS);
	}
	const Vec3 *vel() const {
		return GetStruct<const Vec3 *>(VT_VEL);
	}
	const Vec3 *rot() const {
		return GetStruct<const Vec3 *>(VT_ROT);
	}
	float w() const {
		return GetField<float>(VT_W, 0.0f);
	}
	int32_t ID() const {
		return GetField<int32_t>(VT_ID, 0);
	}
	float Vertical() const {
		return GetField<float>(VT_VERTICAL, 0.0f);
	}
	float Horizontal() const {
		return GetField<float>(VT_HORIZONTAL, 0.0f);
	}
	bool Jump() const {
		return GetField<uint8_t>(VT_JUMP, 0) != 0;
	}
	bool Attack() const {
		return GetField<uint8_t>(VT_ATTACK, 0) != 0;
	}
	bool Run() const {
		return GetField<uint8_t>(VT_RUN, 0) != 0;
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
			VerifyField<int32_t>(verifier, VT_CTYPE) &&
			VerifyField<Vec3>(verifier, VT_POS) &&
			VerifyField<Vec3>(verifier, VT_VEL) &&
			VerifyField<Vec3>(verifier, VT_ROT) &&
			VerifyField<float>(verifier, VT_W) &&
			VerifyField<int32_t>(verifier, VT_ID) &&
			VerifyField<float>(verifier, VT_VERTICAL) &&
			VerifyField<float>(verifier, VT_HORIZONTAL) &&
			VerifyField<uint8_t>(verifier, VT_JUMP) &&
			VerifyField<uint8_t>(verifier, VT_ATTACK) &&
			VerifyField<uint8_t>(verifier, VT_RUN) &&
			verifier.EndTable();
	}
	PlayerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(PlayerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<Player> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlayerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PlayerBuilder {
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_cType(Class cType) {
		fbb_.AddElement<int32_t>(Player::VT_CTYPE, static_cast<int32_t>(cType), 0);
	}
	void add_pos(const Vec3 *pos) {
		fbb_.AddStruct(Player::VT_POS, pos);
	}
	void add_vel(const Vec3 *vel) {
		fbb_.AddStruct(Player::VT_VEL, vel);
	}
	void add_rot(const Vec3 *rot) {
		fbb_.AddStruct(Player::VT_ROT, rot);
	}
	void add_w(float w) {
		fbb_.AddElement<float>(Player::VT_W, w, 0.0f);
	}
	void add_ID(int32_t ID) {
		fbb_.AddElement<int32_t>(Player::VT_ID, ID, 0);
	}
	void add_Vertical(float Vertical) {
		fbb_.AddElement<float>(Player::VT_VERTICAL, Vertical, 0.0f);
	}
	void add_Horizontal(float Horizontal) {
		fbb_.AddElement<float>(Player::VT_HORIZONTAL, Horizontal, 0.0f);
	}
	void add_Jump(bool Jump) {
		fbb_.AddElement<uint8_t>(Player::VT_JUMP, static_cast<uint8_t>(Jump), 0);
	}
	void add_Attack(bool Attack) {
		fbb_.AddElement<uint8_t>(Player::VT_ATTACK, static_cast<uint8_t>(Attack), 0);
	}
	void add_Run(bool Run) {
		fbb_.AddElement<uint8_t>(Player::VT_RUN, static_cast<uint8_t>(Run), 0);
	}
	explicit PlayerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
		: fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	PlayerBuilder &operator=(const PlayerBuilder &);
	flatbuffers::Offset<Player> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Player>(end);
		return o;
	}
};

inline flatbuffers::Offset<Player> CreatePlayer(
	flatbuffers::FlatBufferBuilder &_fbb,
	Class cType = Class_Base,
	const Vec3 *pos = 0,
	const Vec3 *vel = 0,
	const Vec3 *rot = 0,
	float w = 0.0f,
	int32_t ID = 0,
	float Vertical = 0.0f,
	float Horizontal = 0.0f,
	bool Jump = false,
	bool Attack = false,
	bool Run = false) {
	PlayerBuilder builder_(_fbb);
	builder_.add_Horizontal(Horizontal);
	builder_.add_Vertical(Vertical);
	builder_.add_ID(ID);
	builder_.add_w(w);
	builder_.add_rot(rot);
	builder_.add_vel(vel);
	builder_.add_pos(pos);
	builder_.add_cType(cType);
	builder_.add_Run(Run);
	builder_.add_Attack(Attack);
	builder_.add_Jump(Jump);
	return builder_.Finish();
}

flatbuffers::Offset<Player> CreatePlayer(flatbuffers::FlatBufferBuilder &_fbb, const PlayerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MonsterT : public flatbuffers::NativeTable {
	typedef Monster TableType;
	Class cType;
	std::unique_ptr<Vec3> pos;
	int32_t ID;
	int32_t TargetID;
	std::unique_ptr<Vec3> TargetPos;
	float Ani;
	MonsterT()
		: cType(Class_Base),
		ID(0),
		TargetID(0),
		Ani(0.0f) {
	}
};

struct Monster FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef MonsterT NativeTableType;
	enum {
		VT_CTYPE = 4,
		VT_POS = 6,
		VT_ID = 8,
		VT_TARGETID = 10,
		VT_TARGETPOS = 12,
		VT_ANI = 14
	};
	Class cType() const {
		return static_cast<Class>(GetField<int32_t>(VT_CTYPE, 0));
	}
	const Vec3 *pos() const {
		return GetStruct<const Vec3 *>(VT_POS);
	}
	int32_t ID() const {
		return GetField<int32_t>(VT_ID, 0);
	}
	int32_t TargetID() const {
		return GetField<int32_t>(VT_TARGETID, 0);
	}
	const Vec3 *TargetPos() const {
		return GetStruct<const Vec3 *>(VT_TARGETPOS);
	}
	float Ani() const {
		return GetField<float>(VT_ANI, 0.0f);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
			VerifyField<int32_t>(verifier, VT_CTYPE) &&
			VerifyField<Vec3>(verifier, VT_POS) &&
			VerifyField<int32_t>(verifier, VT_ID) &&
			VerifyField<int32_t>(verifier, VT_TARGETID) &&
			VerifyField<Vec3>(verifier, VT_TARGETPOS) &&
			VerifyField<float>(verifier, VT_ANI) &&
			verifier.EndTable();
	}
	MonsterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(MonsterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<Monster> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MonsterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MonsterBuilder {
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_cType(Class cType) {
		fbb_.AddElement<int32_t>(Monster::VT_CTYPE, static_cast<int32_t>(cType), 0);
	}
	void add_pos(const Vec3 *pos) {
		fbb_.AddStruct(Monster::VT_POS, pos);
	}
	void add_ID(int32_t ID) {
		fbb_.AddElement<int32_t>(Monster::VT_ID, ID, 0);
	}
	void add_TargetID(int32_t TargetID) {
		fbb_.AddElement<int32_t>(Monster::VT_TARGETID, TargetID, 0);
	}
	void add_TargetPos(const Vec3 *TargetPos) {
		fbb_.AddStruct(Monster::VT_TARGETPOS, TargetPos);
	}
	void add_Ani(float Ani) {
		fbb_.AddElement<float>(Monster::VT_ANI, Ani, 0.0f);
	}
	explicit MonsterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
		: fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	MonsterBuilder &operator=(const MonsterBuilder &);
	flatbuffers::Offset<Monster> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Monster>(end);
		return o;
	}
};

inline flatbuffers::Offset<Monster> CreateMonster(
	flatbuffers::FlatBufferBuilder &_fbb,
	Class cType = Class_Base,
	const Vec3 *pos = 0,
	int32_t ID = 0,
	int32_t TargetID = 0,
	const Vec3 *TargetPos = 0,
	float Ani = 0.0f) {
	MonsterBuilder builder_(_fbb);
	builder_.add_Ani(Ani);
	builder_.add_TargetPos(TargetPos);
	builder_.add_TargetID(TargetID);
	builder_.add_ID(ID);
	builder_.add_pos(pos);
	builder_.add_cType(cType);
	return builder_.Finish();
}

flatbuffers::Offset<Monster> CreateMonster(flatbuffers::FlatBufferBuilder &_fbb, const MonsterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MonsterStatT : public flatbuffers::NativeTable {
	typedef MonsterStat TableType;
	Class cType;
	int32_t HP;
	int32_t ID;
	MonsterStatT()
		: cType(Class_Base),
		HP(0),
		ID(0) {
	}
};

struct MonsterStat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef MonsterStatT NativeTableType;
	enum {
		VT_CTYPE = 4,
		VT_HP = 6,
		VT_ID = 8
	};
	Class cType() const {
		return static_cast<Class>(GetField<int32_t>(VT_CTYPE, 0));
	}
	int32_t HP() const {
		return GetField<int32_t>(VT_HP, 0);
	}
	int32_t ID() const {
		return GetField<int32_t>(VT_ID, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
			VerifyField<int32_t>(verifier, VT_CTYPE) &&
			VerifyField<int32_t>(verifier, VT_HP) &&
			VerifyField<int32_t>(verifier, VT_ID) &&
			verifier.EndTable();
	}
	MonsterStatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(MonsterStatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<MonsterStat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MonsterStatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MonsterStatBuilder {
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_cType(Class cType) {
		fbb_.AddElement<int32_t>(MonsterStat::VT_CTYPE, static_cast<int32_t>(cType), 0);
	}
	void add_HP(int32_t HP) {
		fbb_.AddElement<int32_t>(MonsterStat::VT_HP, HP, 0);
	}
	void add_ID(int32_t ID) {
		fbb_.AddElement<int32_t>(MonsterStat::VT_ID, ID, 0);
	}
	explicit MonsterStatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
		: fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	MonsterStatBuilder &operator=(const MonsterStatBuilder &);
	flatbuffers::Offset<MonsterStat> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<MonsterStat>(end);
		return o;
	}
};

inline flatbuffers::Offset<MonsterStat> CreateMonsterStat(
	flatbuffers::FlatBufferBuilder &_fbb,
	Class cType = Class_Base,
	int32_t HP = 0,
	int32_t ID = 0) {
	MonsterStatBuilder builder_(_fbb);
	builder_.add_ID(ID);
	builder_.add_HP(HP);
	builder_.add_cType(cType);
	return builder_.Finish();
}

flatbuffers::Offset<MonsterStat> CreateMonsterStat(flatbuffers::FlatBufferBuilder &_fbb, const MonsterStatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PlayerStatT : public flatbuffers::NativeTable {
	typedef PlayerStat TableType;
	Class cType;
	int32_t HP;
	int32_t HPLim;
	int32_t MP;
	int32_t MPLim;
	int32_t LV;
	int32_t ID;
	PlayerStatT()
		: cType(Class_Base),
		HP(0),
		HPLim(0),
		MP(0),
		MPLim(0),
		LV(0),
		ID(0) {
	}
};

struct PlayerStat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef PlayerStatT NativeTableType;
	enum {
		VT_CTYPE = 4,
		VT_HP = 6,
		VT_HPLIM = 8,
		VT_MP = 10,
		VT_MPLIM = 12,
		VT_LV = 14,
		VT_ID = 16
	};
	Class cType() const {
		return static_cast<Class>(GetField<int32_t>(VT_CTYPE, 0));
	}
	int32_t HP() const {
		return GetField<int32_t>(VT_HP, 0);
	}
	int32_t HPLim() const {
		return GetField<int32_t>(VT_HPLIM, 0);
	}
	int32_t MP() const {
		return GetField<int32_t>(VT_MP, 0);
	}
	int32_t MPLim() const {
		return GetField<int32_t>(VT_MPLIM, 0);
	}
	int32_t LV() const {
		return GetField<int32_t>(VT_LV, 0);
	}
	int32_t ID() const {
		return GetField<int32_t>(VT_ID, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
			VerifyField<int32_t>(verifier, VT_CTYPE) &&
			VerifyField<int32_t>(verifier, VT_HP) &&
			VerifyField<int32_t>(verifier, VT_HPLIM) &&
			VerifyField<int32_t>(verifier, VT_MP) &&
			VerifyField<int32_t>(verifier, VT_MPLIM) &&
			VerifyField<int32_t>(verifier, VT_LV) &&
			VerifyField<int32_t>(verifier, VT_ID) &&
			verifier.EndTable();
	}
	PlayerStatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(PlayerStatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<PlayerStat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlayerStatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PlayerStatBuilder {
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_cType(Class cType) {
		fbb_.AddElement<int32_t>(PlayerStat::VT_CTYPE, static_cast<int32_t>(cType), 0);
	}
	void add_HP(int32_t HP) {
		fbb_.AddElement<int32_t>(PlayerStat::VT_HP, HP, 0);
	}
	void add_HPLim(int32_t HPLim) {
		fbb_.AddElement<int32_t>(PlayerStat::VT_HPLIM, HPLim, 0);
	}
	void add_MP(int32_t MP) {
		fbb_.AddElement<int32_t>(PlayerStat::VT_MP, MP, 0);
	}
	void add_MPLim(int32_t MPLim) {
		fbb_.AddElement<int32_t>(PlayerStat::VT_MPLIM, MPLim, 0);
	}
	void add_LV(int32_t LV) {
		fbb_.AddElement<int32_t>(PlayerStat::VT_LV, LV, 0);
	}
	void add_ID(int32_t ID) {
		fbb_.AddElement<int32_t>(PlayerStat::VT_ID, ID, 0);
	}
	explicit PlayerStatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
		: fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	PlayerStatBuilder &operator=(const PlayerStatBuilder &);
	flatbuffers::Offset<PlayerStat> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<PlayerStat>(end);
		return o;
	}
};

inline flatbuffers::Offset<PlayerStat> CreatePlayerStat(
	flatbuffers::FlatBufferBuilder &_fbb,
	Class cType = Class_Base,
	int32_t HP = 0,
	int32_t HPLim = 0,
	int32_t MP = 0,
	int32_t MPLim = 0,
	int32_t LV = 0,
	int32_t ID = 0) {
	PlayerStatBuilder builder_(_fbb);
	builder_.add_ID(ID);
	builder_.add_LV(LV);
	builder_.add_MPLim(MPLim);
	builder_.add_MP(MP);
	builder_.add_HPLim(HPLim);
	builder_.add_HP(HP);
	builder_.add_cType(cType);
	return builder_.Finish();
}

flatbuffers::Offset<PlayerStat> CreatePlayerStat(flatbuffers::FlatBufferBuilder &_fbb, const PlayerStatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SendMeStatT : public flatbuffers::NativeTable {
	typedef SendMeStat TableType;
	Class cType;
	Class StatDataType;
	int32_t ID;
	SendMeStatT()
		: cType(Class_Base),
		StatDataType(Class_Base),
		ID(0) {
	}
};

struct SendMeStat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef SendMeStatT NativeTableType;
	enum {
		VT_CTYPE = 4,
		VT_STATDATATYPE = 6,
		VT_ID = 8
	};
	Class cType() const {
		return static_cast<Class>(GetField<int32_t>(VT_CTYPE, 0));
	}
	Class StatDataType() const {
		return static_cast<Class>(GetField<int32_t>(VT_STATDATATYPE, 0));
	}
	int32_t ID() const {
		return GetField<int32_t>(VT_ID, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
			VerifyField<int32_t>(verifier, VT_CTYPE) &&
			VerifyField<int32_t>(verifier, VT_STATDATATYPE) &&
			VerifyField<int32_t>(verifier, VT_ID) &&
			verifier.EndTable();
	}
	SendMeStatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(SendMeStatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<SendMeStat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SendMeStatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SendMeStatBuilder {
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_cType(Class cType) {
		fbb_.AddElement<int32_t>(SendMeStat::VT_CTYPE, static_cast<int32_t>(cType), 0);
	}
	void add_StatDataType(Class StatDataType) {
		fbb_.AddElement<int32_t>(SendMeStat::VT_STATDATATYPE, static_cast<int32_t>(StatDataType), 0);
	}
	void add_ID(int32_t ID) {
		fbb_.AddElement<int32_t>(SendMeStat::VT_ID, ID, 0);
	}
	explicit SendMeStatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
		: fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	SendMeStatBuilder &operator=(const SendMeStatBuilder &);
	flatbuffers::Offset<SendMeStat> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<SendMeStat>(end);
		return o;
	}
};

inline flatbuffers::Offset<SendMeStat> CreateSendMeStat(
	flatbuffers::FlatBufferBuilder &_fbb,
	Class cType = Class_Base,
	Class StatDataType = Class_Base,
	int32_t ID = 0) {
	SendMeStatBuilder builder_(_fbb);
	builder_.add_ID(ID);
	builder_.add_StatDataType(StatDataType);
	builder_.add_cType(cType);
	return builder_.Finish();
}

flatbuffers::Offset<SendMeStat> CreateSendMeStat(flatbuffers::FlatBufferBuilder &_fbb, const SendMeStatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BaseT : public flatbuffers::NativeTable {
	typedef Base TableType;
	Class cType;
	BaseT()
		: cType(Class_Base) {
	}
};

struct Base FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef BaseT NativeTableType;
	enum {
		VT_CTYPE = 4
	};
	Class cType() const {
		return static_cast<Class>(GetField<int32_t>(VT_CTYPE, 0));
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
			VerifyField<int32_t>(verifier, VT_CTYPE) &&
			verifier.EndTable();
	}
	BaseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(BaseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<Base> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BaseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BaseBuilder {
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_cType(Class cType) {
		fbb_.AddElement<int32_t>(Base::VT_CTYPE, static_cast<int32_t>(cType), 0);
	}
	explicit BaseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
		: fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	BaseBuilder &operator=(const BaseBuilder &);
	flatbuffers::Offset<Base> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Base>(end);
		return o;
	}
};

inline flatbuffers::Offset<Base> CreateBase(
	flatbuffers::FlatBufferBuilder &_fbb,
	Class cType = Class_Base) {
	BaseBuilder builder_(_fbb);
	builder_.add_cType(cType);
	return builder_.Finish();
}

flatbuffers::Offset<Base> CreateBase(flatbuffers::FlatBufferBuilder &_fbb, const BaseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline FirstCharacterDataT *FirstCharacterData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	auto _o = new FirstCharacterDataT();
	UnPackTo(_o, _resolver);
	return _o;
}

inline void FirstCharacterData::UnPackTo(FirstCharacterDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{ auto _e = cType(); _o->cType = _e; };
	{ auto _e = Pos(); if (_e) _o->Pos = std::unique_ptr<Vec3>(new Vec3(*_e)); };
	{ auto _e = HP(); _o->HP = _e; };
	{ auto _e = HPLim(); _o->HPLim = _e; };
	{ auto _e = MP(); _o->MP = _e; };
	{ auto _e = MPLim(); _o->MPLim = _e; };
	{ auto _e = LV(); _o->LV = _e; };
	{ auto _e = ID(); _o->ID = _e; };
}

inline flatbuffers::Offset<FirstCharacterData> FirstCharacterData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FirstCharacterDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateFirstCharacterData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FirstCharacterData> CreateFirstCharacterData(flatbuffers::FlatBufferBuilder &_fbb, const FirstCharacterDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FirstCharacterDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher }; (void)_va;
	auto _cType = _o->cType;
	auto _Pos = _o->Pos ? _o->Pos.get() : 0;
	auto _HP = _o->HP;
	auto _HPLim = _o->HPLim;
	auto _MP = _o->MP;
	auto _MPLim = _o->MPLim;
	auto _LV = _o->LV;
	auto _ID = _o->ID;
	return CreateFirstCharacterData(
		_fbb,
		_cType,
		_Pos,
		_HP,
		_HPLim,
		_MP,
		_MPLim,
		_LV,
		_ID);
}

inline LoginT *Login::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	auto _o = new LoginT();
	UnPackTo(_o, _resolver);
	return _o;
}

inline void Login::UnPackTo(LoginT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{ auto _e = cType(); _o->cType = _e; };
	{ auto _e = isSignin(); _o->isSignin = _e; };
	{ auto _e = id(); if (_e) _o->id = _e->str(); };
	{ auto _e = pass(); if (_e) _o->pass = _e->str(); };
	{ auto _e = isSuccess(); _o->isSuccess = _e; };
}

inline flatbuffers::Offset<Login> Login::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoginT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateLogin(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Login> CreateLogin(flatbuffers::FlatBufferBuilder &_fbb, const LoginT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LoginT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher }; (void)_va;
	auto _cType = _o->cType;
	auto _isSignin = _o->isSignin;
	auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
	auto _pass = _o->pass.empty() ? 0 : _fbb.CreateString(_o->pass);
	auto _isSuccess = _o->isSuccess;
	return CreateLogin(
		_fbb,
		_cType,
		_isSignin,
		_id,
		_pass,
		_isSuccess);
}

inline idT *id::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	auto _o = new idT();
	UnPackTo(_o, _resolver);
	return _o;
}

inline void id::UnPackTo(idT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{ auto _e = cType(); _o->cType = _e; };
	{ auto _e = ID(); _o->ID = _e; };
}

inline flatbuffers::Offset<id> id::Pack(flatbuffers::FlatBufferBuilder &_fbb, const idT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
	return Createid(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<id> Createid(flatbuffers::FlatBufferBuilder &_fbb, const idT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const idT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher }; (void)_va;
	auto _cType = _o->cType;
	auto _ID = _o->ID;
	return Createid(
		_fbb,
		_cType,
		_ID);
}

inline pingT *ping::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	auto _o = new pingT();
	UnPackTo(_o, _resolver);
	return _o;
}

inline void ping::UnPackTo(pingT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{ auto _e = cType(); _o->cType = _e; };
	{ auto _e = time(); _o->time = _e; };
}

inline flatbuffers::Offset<ping> ping::Pack(flatbuffers::FlatBufferBuilder &_fbb, const pingT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
	return Createping(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ping> Createping(flatbuffers::FlatBufferBuilder &_fbb, const pingT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const pingT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher }; (void)_va;
	auto _cType = _o->cType;
	auto _time = _o->time;
	return Createping(
		_fbb,
		_cType,
		_time);
}

inline testT *test::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	auto _o = new testT();
	UnPackTo(_o, _resolver);
	return _o;
}

inline void test::UnPackTo(testT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{ auto _e = cType(); _o->cType = _e; };
	{ auto _e = num(); _o->num = _e; };
}

inline flatbuffers::Offset<test> test::Pack(flatbuffers::FlatBufferBuilder &_fbb, const testT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
	return Createtest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<test> Createtest(flatbuffers::FlatBufferBuilder &_fbb, const testT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const testT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher }; (void)_va;
	auto _cType = _o->cType;
	auto _num = _o->num;
	return Createtest(
		_fbb,
		_cType,
		_num);
}

inline PlayerT *Player::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	auto _o = new PlayerT();
	UnPackTo(_o, _resolver);
	return _o;
}

inline void Player::UnPackTo(PlayerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{ auto _e = cType(); _o->cType = _e; };
	{ auto _e = pos(); if (_e) _o->pos = std::unique_ptr<Vec3>(new Vec3(*_e)); };
	{ auto _e = vel(); if (_e) _o->vel = std::unique_ptr<Vec3>(new Vec3(*_e)); };
	{ auto _e = rot(); if (_e) _o->rot = std::unique_ptr<Vec3>(new Vec3(*_e)); };
	{ auto _e = w(); _o->w = _e; };
	{ auto _e = ID(); _o->ID = _e; };
	{ auto _e = Vertical(); _o->Vertical = _e; };
	{ auto _e = Horizontal(); _o->Horizontal = _e; };
	{ auto _e = Jump(); _o->Jump = _e; };
	{ auto _e = Attack(); _o->Attack = _e; };
	{ auto _e = Run(); _o->Run = _e; };
}

inline flatbuffers::Offset<Player> Player::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlayerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreatePlayer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Player> CreatePlayer(flatbuffers::FlatBufferBuilder &_fbb, const PlayerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PlayerT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher }; (void)_va;
	auto _cType = _o->cType;
	auto _pos = _o->pos ? _o->pos.get() : 0;
	auto _vel = _o->vel ? _o->vel.get() : 0;
	auto _rot = _o->rot ? _o->rot.get() : 0;
	auto _w = _o->w;
	auto _ID = _o->ID;
	auto _Vertical = _o->Vertical;
	auto _Horizontal = _o->Horizontal;
	auto _Jump = _o->Jump;
	auto _Attack = _o->Attack;
	auto _Run = _o->Run;
	return CreatePlayer(
		_fbb,
		_cType,
		_pos,
		_vel,
		_rot,
		_w,
		_ID,
		_Vertical,
		_Horizontal,
		_Jump,
		_Attack,
		_Run);
}

inline MonsterT *Monster::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	auto _o = new MonsterT();
	UnPackTo(_o, _resolver);
	return _o;
}

inline void Monster::UnPackTo(MonsterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{ auto _e = cType(); _o->cType = _e; };
	{ auto _e = pos(); if (_e) _o->pos = std::unique_ptr<Vec3>(new Vec3(*_e)); };
	{ auto _e = ID(); _o->ID = _e; };
	{ auto _e = TargetID(); _o->TargetID = _e; };
	{ auto _e = TargetPos(); if (_e) _o->TargetPos = std::unique_ptr<Vec3>(new Vec3(*_e)); };
	{ auto _e = Ani(); _o->Ani = _e; };
}

inline flatbuffers::Offset<Monster> Monster::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MonsterT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateMonster(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Monster> CreateMonster(flatbuffers::FlatBufferBuilder &_fbb, const MonsterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MonsterT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher }; (void)_va;
	auto _cType = _o->cType;
	auto _pos = _o->pos ? _o->pos.get() : 0;
	auto _ID = _o->ID;
	auto _TargetID = _o->TargetID;
	auto _TargetPos = _o->TargetPos ? _o->TargetPos.get() : 0;
	auto _Ani = _o->Ani;
	return CreateMonster(
		_fbb,
		_cType,
		_pos,
		_ID,
		_TargetID,
		_TargetPos,
		_Ani);
}

inline MonsterStatT *MonsterStat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	auto _o = new MonsterStatT();
	UnPackTo(_o, _resolver);
	return _o;
}

inline void MonsterStat::UnPackTo(MonsterStatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{ auto _e = cType(); _o->cType = _e; };
	{ auto _e = HP(); _o->HP = _e; };
	{ auto _e = ID(); _o->ID = _e; };
}

inline flatbuffers::Offset<MonsterStat> MonsterStat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MonsterStatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateMonsterStat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MonsterStat> CreateMonsterStat(flatbuffers::FlatBufferBuilder &_fbb, const MonsterStatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MonsterStatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher }; (void)_va;
	auto _cType = _o->cType;
	auto _HP = _o->HP;
	auto _ID = _o->ID;
	return CreateMonsterStat(
		_fbb,
		_cType,
		_HP,
		_ID);
}

inline PlayerStatT *PlayerStat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	auto _o = new PlayerStatT();
	UnPackTo(_o, _resolver);
	return _o;
}

inline void PlayerStat::UnPackTo(PlayerStatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{ auto _e = cType(); _o->cType = _e; };
	{ auto _e = HP(); _o->HP = _e; };
	{ auto _e = HPLim(); _o->HPLim = _e; };
	{ auto _e = MP(); _o->MP = _e; };
	{ auto _e = MPLim(); _o->MPLim = _e; };
	{ auto _e = LV(); _o->LV = _e; };
	{ auto _e = ID(); _o->ID = _e; };
}

inline flatbuffers::Offset<PlayerStat> PlayerStat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlayerStatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreatePlayerStat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PlayerStat> CreatePlayerStat(flatbuffers::FlatBufferBuilder &_fbb, const PlayerStatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PlayerStatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher }; (void)_va;
	auto _cType = _o->cType;
	auto _HP = _o->HP;
	auto _HPLim = _o->HPLim;
	auto _MP = _o->MP;
	auto _MPLim = _o->MPLim;
	auto _LV = _o->LV;
	auto _ID = _o->ID;
	return CreatePlayerStat(
		_fbb,
		_cType,
		_HP,
		_HPLim,
		_MP,
		_MPLim,
		_LV,
		_ID);
}

inline SendMeStatT *SendMeStat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	auto _o = new SendMeStatT();
	UnPackTo(_o, _resolver);
	return _o;
}

inline void SendMeStat::UnPackTo(SendMeStatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{ auto _e = cType(); _o->cType = _e; };
	{ auto _e = StatDataType(); _o->StatDataType = _e; };
	{ auto _e = ID(); _o->ID = _e; };
}

inline flatbuffers::Offset<SendMeStat> SendMeStat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SendMeStatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateSendMeStat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SendMeStat> CreateSendMeStat(flatbuffers::FlatBufferBuilder &_fbb, const SendMeStatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SendMeStatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher }; (void)_va;
	auto _cType = _o->cType;
	auto _StatDataType = _o->StatDataType;
	auto _ID = _o->ID;
	return CreateSendMeStat(
		_fbb,
		_cType,
		_StatDataType,
		_ID);
}

inline BaseT *Base::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	auto _o = new BaseT();
	UnPackTo(_o, _resolver);
	return _o;
}

inline void Base::UnPackTo(BaseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{ auto _e = cType(); _o->cType = _e; };
}

inline flatbuffers::Offset<Base> Base::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BaseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateBase(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Base> CreateBase(flatbuffers::FlatBufferBuilder &_fbb, const BaseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BaseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher }; (void)_va;
	auto _cType = _o->cType;
	return CreateBase(
		_fbb,
		_cType);
}

inline const Base *GetBase(const void *buf) {
	return flatbuffers::GetRoot<Base>(buf);
}

inline const Base *GetSizePrefixedBase(const void *buf) {
	return flatbuffers::GetSizePrefixedRoot<Base>(buf);
}

inline bool VerifyBaseBuffer(
	flatbuffers::Verifier &verifier) {
	return verifier.VerifyBuffer<Base>(nullptr);
}

inline bool VerifySizePrefixedBaseBuffer(
	flatbuffers::Verifier &verifier) {
	return verifier.VerifySizePrefixedBuffer<Base>(nullptr);
}

inline void FinishBaseBuffer(
	flatbuffers::FlatBufferBuilder &fbb,
	flatbuffers::Offset<Base> root) {
	fbb.Finish(root);
}

inline void FinishSizePrefixedBaseBuffer(
	flatbuffers::FlatBufferBuilder &fbb,
	flatbuffers::Offset<Base> root) {
	fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<BaseT> UnPackBase(
	const void *buf,
	const flatbuffers::resolver_function_t *res = nullptr) {
	return std::unique_ptr<BaseT>(GetBase(buf)->UnPack(res));
}

#endif  // FLATBUFFERS_GENERATED_BASE_H_
